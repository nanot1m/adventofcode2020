// @ts-check

require("./solution")({
  input: require("./input").fetchFromAoC,
  solve: (входныеДанные) => [
    () => часть1(входныеДанные),
    () => часть2(входныеДанные),
  ],
});

/**
 *
 * @param {string} входныеДанные
 */
function часть1(входныеДанные) {
  const списокСписковСмещений = преобразоватьВходныеДанные(входныеДанные);

  const конечныеПозиции = списокСписковСмещений.map(посчитатьКонечнуюПозицию);

  const позицииЧёрных = new Set();
  for (const позиция of конечныеПозиции) {
    const ключ = позиция.toString();
    if (!позицииЧёрных.delete(ключ)) {
      позицииЧёрных.add(ключ);
    }
  }

  return позицииЧёрных.size;
}

/**
 * @param {string} входныеДанные
 */
function часть2(входныеДанные) {
  const списокСписковСмещений = преобразоватьВходныеДанные(входныеДанные);

  const конечныеПозиции = списокСписковСмещений.map(посчитатьКонечнуюПозицию);

  let позицииЧёрных = new Set();
  for (const ключ of конечныеПозиции) {
    const key = ключ.toString();
    if (!позицииЧёрных.delete(key)) {
      позицииЧёрных.add(key);
    }
  }

  for (let и = 0; и < 100; и++) {
    позицииЧёрных = вычислитьСледующееСостояние(позицииЧёрных);
  }

  return позицииЧёрных.size;
}

const ПЕРЕВОДЫ = {
  Восток: "e",
  Запад: "w",
  СевероВосток: "ne",
  СевероЗапад: "nw",
  ЮгоВосток: "se",
  ЮгоЗапад: "sw",
};

const ГЕКС_СМЕЩЕНИЯ = {
  [ПЕРЕВОДЫ.Восток]: [2, 0],
  [ПЕРЕВОДЫ.Запад]: [-2, 0],
  [ПЕРЕВОДЫ.СевероВосток]: [1, 1],
  [ПЕРЕВОДЫ.СевероЗапад]: [-1, 1],
  [ПЕРЕВОДЫ.ЮгоВосток]: [1, -1],
  [ПЕРЕВОДЫ.ЮгоЗапад]: [-1, -1],
};

/**
 * @param {string} входныеДанные
 */
function преобразоватьВходныеДанные(входныеДанные) {
  const направления = [
    ПЕРЕВОДЫ.СевероВосток,
    ПЕРЕВОДЫ.СевероЗапад,
    ПЕРЕВОДЫ.ЮгоВосток,
    ПЕРЕВОДЫ.ЮгоЗапад,
    ПЕРЕВОДЫ.Восток,
    ПЕРЕВОДЫ.Запад,
  ];
  return входныеДанные.split("\n").map((строка) => {
    const жесть = строка
      .replace(
        new RegExp(`(${направления.join("|")})`, "g"),
        (_, направление) => `[${ГЕКС_СМЕЩЕНИЯ[направление]}],`
      )
      .slice(0, -1);
    return JSON.parse(`[${жесть}]`);
  });
}

/**
 * @param {Array<number[]>} смещения
 */
function посчитатьКонечнуюПозицию(смещения) {
  return смещения.reduce(
    (позиция, смещение) =>
      позиция.map((координата, индекс) => координата + смещение[индекс]),
    [0, 0]
  );
}

const соседи = Object.values(ГЕКС_СМЕЩЕНИЯ);
const окрестность = [[0, 0], ...соседи];

/**
 *
 * @param {Set<string>} состояние
 * @param {number} икс
 * @param {number} игрик
 */
function посчитатьЧёрныхСоседей(состояние, икс, игрик) {
  return соседи.filter(([дельтаИкс, дельтаИгрик]) =>
    состояние.has([икс + дельтаИкс, игрик + дельтаИгрик].toString())
  ).length;
}

/**
 * @param {Set<string>} состояние
 */
function вычислитьСледующееСостояние(состояние) {
  const следующееСостояние = new Set();

  состояние.forEach((координаты) => {
    const [икс, игрик] = координаты.split(",").map(Number);
    окрестность.forEach(([дельтаИкс, дельтаИгрик]) => {
      let икс2 = икс + дельтаИкс;
      let игрик2 = игрик + дельтаИгрик;

      const числоЧёрныхСоседей = посчитатьЧёрныхСоседей(
        состояние,
        икс2,
        игрик2
      );

      if (состояние.has([икс2, игрик2].toString())) {
        if (числоЧёрныхСоседей === 1 || числоЧёрныхСоседей === 2) {
          следующееСостояние.add([икс2, игрик2].toString());
        }
      } else {
        if (числоЧёрныхСоседей === 2) {
          следующееСостояние.add([икс2, игрик2].toString());
        }
      }
    });
  });

  return следующееСостояние;
}
